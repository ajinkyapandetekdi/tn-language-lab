import { Injectable, Inject } from '@angular/core';
import { throwError, of, ReplaySubject } from 'rxjs';
import { mergeMap, catchError, tap } from 'rxjs/operators';
import { JSONValidator } from '../validation/json-validator';
import { IndexedDBDatabase } from '../databases/indexeddb-database';
import { LocalStorageDatabase } from '../databases/localstorage-database';
import { MemoryDatabase } from '../databases/memory-database';
import { IDB_BROKEN_ERROR } from '../databases/exceptions';
import { LS_PREFIX } from '../tokens';
import { ValidationError } from './exceptions';
import * as i0 from "@angular/core";
import * as i1 from "../databases/local-database";
import * as i2 from "../validation/json-validator";
export class StorageMap {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param database Storage to use
     * @param jsonValidator Validator service
     * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain or for interoperability
     */
    constructor(database, jsonValidator = new JSONValidator(), LSPrefix = '') {
        this.database = database;
        this.jsonValidator = jsonValidator;
        this.LSPrefix = LSPrefix;
        this.notifiers = new Map();
    }
    /**
     * **Number of items** in storage, wrapped in an `Observable`.
     *
     * @example
     * this.storageMap.size.subscribe((size) => {
     *   console.log(size);
     * });
     */
    get size() {
        return this.database.size
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.size));
    }
    /**
     * Tells you which storage engine is used. *Only useful for interoperability.*
     * Note that due to some browsers issues in some special contexts
     * (Firefox private mode and Safari cross-origin iframes),
     * **this information may be wrong at initialization,**
     * as the storage could fallback from `indexedDB` to `localStorage`
     * only after a first read or write operation.
     * @returns Storage engine used
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {}
     */
    get backingEngine() {
        if (this.database instanceof IndexedDBDatabase) {
            return 'indexedDB';
        }
        else if (this.database instanceof LocalStorageDatabase) {
            return 'localStorage';
        }
        else if (this.database instanceof MemoryDatabase) {
            return 'memory';
        }
        else {
            return 'unknown';
        }
    }
    /**
     * Info about `indexedDB` database. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version.
     * **Values will be empty if the storage is not `indexedDB`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'indexedDB') {
     *   const { database, store, version } = this.storageMap.backingStore;
     * }
     */
    get backingStore() {
        return (this.database instanceof IndexedDBDatabase) ?
            this.database.backingStore :
            { database: '', store: '', version: 0 };
    }
    /**
     * Info about `localStorage` fallback storage. *Only useful for interoperability.*
     * @returns `localStorage` prefix.
     * **Values will be empty if the storage is not `localStorage`,**
     * **so it should be used after an engine check**.
     *
     * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/INTEROPERABILITY.md}
     *
     * @example
     * if (this.storageMap.backingEngine === 'localStorage') {
     *   const { prefix } = this.storageMap.fallbackBackingStore;
     * }
     */
    get fallbackBackingStore() {
        return (this.database instanceof LocalStorageDatabase) ?
            { prefix: this.database.prefix } :
            { prefix: '' };
    }
    get(key, schema) {
        /* Get the data in storage */
        return this.database.get(key).pipe(
        /* Check if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.get(key)), mergeMap((data) => {
            /* No need to validate if the data is empty */
            if ((data === undefined) || (data === null)) {
                return of(undefined);
            }
            else if (schema) {
                /* Validate data against a JSON schema if provided */
                if (!this.jsonValidator.validate(data, schema)) {
                    return throwError(new ValidationError());
                }
                /* Data have been checked, so it's OK to cast */
                return of(data);
            }
            /* Cast to unknown as the data wasn't checked */
            return of(data);
        }));
    }
    /**
     * Set an item in storage.
     * Note that setting `null` or `undefined` will remove the item to avoid some browsers issues.
     * @param key The item's key
     * @param data The item's value
     * @param schema Optional JSON schema to validate the data
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.set('key', 'value').subscribe(() => {});
     */
    set(key, data, schema) {
        /* Storing `undefined` or `null` is useless and can cause issues in `indexedDb` in some browsers,
         * so removing item instead for all storages to have a consistent API */
        if ((data === undefined) || (data === null)) {
            return this.delete(key);
        }
        /* Validate data against a JSON schema if provided */
        if (schema && !this.jsonValidator.validate(data, schema)) {
            return throwError(new ValidationError());
        }
        return this.database.set(key, data).pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.set(key, data)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.notify(key, data); }));
    }
    /**
     * Delete an item in storage
     * @param key The item's key
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.delete('key').subscribe(() => {});
     */
    delete(key) {
        return this.database.delete(key).pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.delete(key)), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => { this.notify(key, undefined); }));
    }
    /**
     * Delete all items in storage
     * @returns A RxJS `Observable` to wait the end of the operation
     *
     * @example
     * this.storageMap.clear().subscribe(() => {});
     */
    clear() {
        return this.database.clear().pipe(
        /* Catch if `indexedDb` is broken */
        this.catchIDBBroken(() => this.database.clear()), 
        /* Notify watchers (must be last because it should only happen if the operation succeeds) */
        tap(() => {
            for (const key of this.notifiers.keys()) {
                this.notify(key, undefined);
            }
        }));
    }
    /**
     * Get all keys stored in storage. Note **this is an *iterating* `Observable`**:
     * * if there is no key, the `next` callback will not be invoked,
     * * if you need to wait the whole operation to end, be sure to act in the `complete` callback,
     * as this `Observable` can emit several values and so will invoke the `next` callback several times.
     * @returns A list of the keys wrapped in a RxJS `Observable`
     *
     * @example
     * this.storageMap.keys().subscribe({
     *   next: (key) => { console.log(key); },
     *   complete: () => { console.log('Done'); },
     * });
     */
    keys() {
        return this.database.keys()
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.keys()));
    }
    /**
     * Tells if a key exists in storage
     * @returns A RxJS `Observable` telling if the key exists
     *
     * @example
     * this.storageMap.has('key').subscribe((hasKey) => {
     *   if (hasKey) {}
     * });
     */
    has(key) {
        return this.database.has(key)
            /* Catch if `indexedDb` is broken */
            .pipe(this.catchIDBBroken(() => this.database.has(key)));
    }
    watch(key, schema) {
        /* Check if there is already a notifier */
        if (!this.notifiers.has(key)) {
            this.notifiers.set(key, new ReplaySubject(1));
        }
        /* Non-null assertion is required because TypeScript doesn't narrow `.has()` yet */
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const notifier = this.notifiers.get(key);
        /* Get the current item value */
        (schema ? this.get(key, schema) : this.get(key)).subscribe({
            next: (result) => notifier.next(result),
            error: (error) => notifier.error(error),
        });
        /* Only the public API of the `Observable` should be returned */
        return (schema ?
            notifier.asObservable() :
            notifier.asObservable());
    }
    /**
     * Notify when a value changes
     * @param key The item's key
     * @param data The new value
     */
    notify(key, value) {
        const notifier = this.notifiers.get(key);
        if (notifier) {
            notifier.next(value);
        }
    }
    /**
     * RxJS operator to catch if `indexedDB` is broken
     * @param operationCallback Callback with the operation to redo
     */
    catchIDBBroken(operationCallback) {
        return catchError((error) => {
            /* Check if `indexedDB` is broken based on error message (the specific error class seems to be lost in the process) */
            if ((error !== undefined) && (error !== null)
                && (typeof error === 'object') && ('message' in error)
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                && (error.message === IDB_BROKEN_ERROR)) {
                /* When storage is fully disabled in browser (via the "Block all cookies" option),
                 * just trying to check `localStorage` variable causes a security exception.
                 * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
                 */
                try {
                    if ('getItem' in localStorage) {
                        /* Fallback to `localStorage` if available */
                        this.database = new LocalStorageDatabase(this.LSPrefix);
                    }
                    else {
                        /* Fallback to memory storage otherwise */
                        this.database = new MemoryDatabase();
                    }
                }
                catch {
                    /* Fallback to memory storage otherwise */
                    this.database = new MemoryDatabase();
                }
                /* Redo the operation */
                return operationCallback();
            }
            else {
                /* Otherwise, rethrow the error */
                return throwError(error);
            }
        });
    }
}
StorageMap.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: StorageMap, deps: [{ token: i1.LocalDatabase }, { token: i2.JSONValidator }, { token: LS_PREFIX }], target: i0.ɵɵFactoryTarget.Injectable });
StorageMap.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: StorageMap, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: StorageMap, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.LocalDatabase }, { type: i2.JSONValidator }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LS_PREFIX]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS1tYXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1wd2EvbG9jYWwtc3RvcmFnZS9zcmMvbGliL3N0b3JhZ2VzL3N0b3JhZ2UtbWFwLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFjLFVBQVUsRUFBRSxFQUFFLEVBQW9CLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNuRixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU0zRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDcEUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDMUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBRTlELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzNELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDdEMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7OztBQUsvQyxNQUFNLE9BQU8sVUFBVTtJQUlyQjs7Ozs7T0FLRztJQUNILFlBQ1ksUUFBdUIsRUFDdkIsZ0JBQStCLElBQUksYUFBYSxFQUFFLEVBQy9CLFdBQVcsRUFBRTtRQUZoQyxhQUFRLEdBQVIsUUFBUSxDQUFlO1FBQ3ZCLGtCQUFhLEdBQWIsYUFBYSxDQUFxQztRQUMvQixhQUFRLEdBQVIsUUFBUSxDQUFLO1FBWGxDLGNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBa0MsQ0FBQztJQVk3RCxDQUFDO0lBRUo7Ozs7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SUFBSSxTQUFTLElBQUksWUFBWSxFQUFFO3dCQUU3Qiw2Q0FBNkM7d0JBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7cUJBRXpEO3lCQUFNO3dCQUVMLDBDQUEwQzt3QkFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO3FCQUV0QztpQkFFRjtnQkFBQyxNQUFNO29CQUVOLDBDQUEwQztvQkFDMUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFDO2lCQUV0QztnQkFFRCx3QkFBd0I7Z0JBQ3hCLE9BQU8saUJBQWlCLEVBQUUsQ0FBQzthQUU1QjtpQkFBTTtnQkFFTCxrQ0FBa0M7Z0JBQ2xDLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBRTFCO1FBRUgsQ0FBQyxDQUFDLENBQUM7SUFFTCxDQUFDOzt1R0FwWlUsVUFBVSw0RUFhWCxTQUFTOzJHQWJSLFVBQVUsY0FGVCxNQUFNOzJGQUVQLFVBQVU7a0JBSHRCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkFjSSxNQUFNOzJCQUFDLFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IsIG9mLCBPcGVyYXRvckZ1bmN0aW9uLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtZXJnZU1hcCwgY2F0Y2hFcnJvciwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1xuICBKU09OU2NoZW1hLCBKU09OU2NoZW1hQm9vbGVhbiwgSlNPTlNjaGVtYUludGVnZXIsXG4gIEpTT05TY2hlbWFOdW1iZXIsIEpTT05TY2hlbWFTdHJpbmcsIEpTT05TY2hlbWFBcnJheU9mXG59IGZyb20gJy4uL3ZhbGlkYXRpb24vanNvbi1zY2hlbWEnO1xuaW1wb3J0IHsgSlNPTlZhbGlkYXRvciB9IGZyb20gJy4uL3ZhbGlkYXRpb24vanNvbi12YWxpZGF0b3InO1xuaW1wb3J0IHsgSW5kZXhlZERCRGF0YWJhc2UgfSBmcm9tICcuLi9kYXRhYmFzZXMvaW5kZXhlZGRiLWRhdGFiYXNlJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZURhdGFiYXNlIH0gZnJvbSAnLi4vZGF0YWJhc2VzL2xvY2Fsc3RvcmFnZS1kYXRhYmFzZSc7XG5pbXBvcnQgeyBNZW1vcnlEYXRhYmFzZSB9IGZyb20gJy4uL2RhdGFiYXNlcy9tZW1vcnktZGF0YWJhc2UnO1xuaW1wb3J0IHsgTG9jYWxEYXRhYmFzZSB9IGZyb20gJy4uL2RhdGFiYXNlcy9sb2NhbC1kYXRhYmFzZSc7XG5pbXBvcnQgeyBJREJfQlJPS0VOX0VSUk9SIH0gZnJvbSAnLi4vZGF0YWJhc2VzL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHsgTFNfUFJFRklYIH0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IFZhbGlkYXRpb25FcnJvciB9IGZyb20gJy4vZXhjZXB0aW9ucyc7XG5cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFN0b3JhZ2VNYXAge1xuXG4gIHByb3RlY3RlZCBub3RpZmllcnMgPSBuZXcgTWFwPHN0cmluZywgUmVwbGF5U3ViamVjdDx1bmtub3duPj4oKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgcGFyYW1zIGFyZSBwcm92aWRlZCBieSBBbmd1bGFyIChidXQgY2FuIGFsc28gYmUgcGFzc2VkIG1hbnVhbGx5IGluIHRlc3RzKVxuICAgKiBAcGFyYW0gZGF0YWJhc2UgU3RvcmFnZSB0byB1c2VcbiAgICogQHBhcmFtIGpzb25WYWxpZGF0b3IgVmFsaWRhdG9yIHNlcnZpY2VcbiAgICogQHBhcmFtIExTUHJlZml4IFByZWZpeCBmb3IgYGxvY2FsU3RvcmFnZWAga2V5cyB0byBhdm9pZCBjb2xsaXNpb24gZm9yIG11bHRpcGxlIGFwcHMgb24gdGhlIHNhbWUgc3ViZG9tYWluIG9yIGZvciBpbnRlcm9wZXJhYmlsaXR5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgZGF0YWJhc2U6IExvY2FsRGF0YWJhc2UsXG4gICAgcHJvdGVjdGVkIGpzb25WYWxpZGF0b3I6IEpTT05WYWxpZGF0b3IgPSBuZXcgSlNPTlZhbGlkYXRvcigpLFxuICAgIEBJbmplY3QoTFNfUFJFRklYKSBwcm90ZWN0ZWQgTFNQcmVmaXggPSAnJyxcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiAqKk51bWJlciBvZiBpdGVtcyoqIGluIHN0b3JhZ2UsIHdyYXBwZWQgaW4gYW4gYE9ic2VydmFibGVgLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuc2l6ZS5zdWJzY3JpYmUoKHNpemUpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhzaXplKTtcbiAgICogfSk7XG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2Uuc2l6ZVxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICAucGlwZSh0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2Uuc2l6ZSkpO1xuXG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgeW91IHdoaWNoIHN0b3JhZ2UgZW5naW5lIGlzIHVzZWQuICpPbmx5IHVzZWZ1bCBmb3IgaW50ZXJvcGVyYWJpbGl0eS4qXG4gICAqIE5vdGUgdGhhdCBkdWUgdG8gc29tZSBicm93c2VycyBpc3N1ZXMgaW4gc29tZSBzcGVjaWFsIGNvbnRleHRzXG4gICAqIChGaXJlZm94IHByaXZhdGUgbW9kZSBhbmQgU2FmYXJpIGNyb3NzLW9yaWdpbiBpZnJhbWVzKSxcbiAgICogKip0aGlzIGluZm9ybWF0aW9uIG1heSBiZSB3cm9uZyBhdCBpbml0aWFsaXphdGlvbiwqKlxuICAgKiBhcyB0aGUgc3RvcmFnZSBjb3VsZCBmYWxsYmFjayBmcm9tIGBpbmRleGVkREJgIHRvIGBsb2NhbFN0b3JhZ2VgXG4gICAqIG9ubHkgYWZ0ZXIgYSBmaXJzdCByZWFkIG9yIHdyaXRlIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgU3RvcmFnZSBlbmdpbmUgdXNlZFxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL0lOVEVST1BFUkFCSUxJVFkubWR9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGlmICh0aGlzLnN0b3JhZ2VNYXAuYmFja2luZ0VuZ2luZSA9PT0gJ2luZGV4ZWREQicpIHt9XG4gICAqL1xuICBnZXQgYmFja2luZ0VuZ2luZSgpOiAnaW5kZXhlZERCJyB8ICdsb2NhbFN0b3JhZ2UnIHwgJ21lbW9yeScgfCAndW5rbm93bicge1xuXG4gICAgaWYgKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBJbmRleGVkREJEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gJ2luZGV4ZWREQic7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBMb2NhbFN0b3JhZ2VEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gJ2xvY2FsU3RvcmFnZSc7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBNZW1vcnlEYXRhYmFzZSkge1xuXG4gICAgICByZXR1cm4gJ21lbW9yeSc7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuXG4gICAgfVxuXG4gIH1cblxuICAvKipcbiAgICogSW5mbyBhYm91dCBgaW5kZXhlZERCYCBkYXRhYmFzZS4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogQHJldHVybnMgYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZSwgc3RvcmUgbmFtZSBhbmQgZGF0YWJhc2UgdmVyc2lvbi5cbiAgICogKipWYWx1ZXMgd2lsbCBiZSBlbXB0eSBpZiB0aGUgc3RvcmFnZSBpcyBub3QgYGluZGV4ZWREQmAsKipcbiAgICogKipzbyBpdCBzaG91bGQgYmUgdXNlZCBhZnRlciBhbiBlbmdpbmUgY2hlY2sqKi5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9ibG9iL21haW4vZG9jcy9JTlRFUk9QRVJBQklMSVRZLm1kfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBpZiAodGhpcy5zdG9yYWdlTWFwLmJhY2tpbmdFbmdpbmUgPT09ICdpbmRleGVkREInKSB7XG4gICAqICAgY29uc3QgeyBkYXRhYmFzZSwgc3RvcmUsIHZlcnNpb24gfSA9IHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBiYWNraW5nU3RvcmUoKTogeyBkYXRhYmFzZTogc3RyaW5nLCBzdG9yZTogc3RyaW5nLCB2ZXJzaW9uOiBudW1iZXIgfSB7XG5cbiAgICByZXR1cm4gKHRoaXMuZGF0YWJhc2UgaW5zdGFuY2VvZiBJbmRleGVkREJEYXRhYmFzZSkgP1xuICAgICAgdGhpcy5kYXRhYmFzZS5iYWNraW5nU3RvcmUgOlxuICAgICAgeyBkYXRhYmFzZTogJycsIHN0b3JlOiAnJywgdmVyc2lvbjogMCB9O1xuXG4gIH1cblxuICAvKipcbiAgICogSW5mbyBhYm91dCBgbG9jYWxTdG9yYWdlYCBmYWxsYmFjayBzdG9yYWdlLiAqT25seSB1c2VmdWwgZm9yIGludGVyb3BlcmFiaWxpdHkuKlxuICAgKiBAcmV0dXJucyBgbG9jYWxTdG9yYWdlYCBwcmVmaXguXG4gICAqICoqVmFsdWVzIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHN0b3JhZ2UgaXMgbm90IGBsb2NhbFN0b3JhZ2VgLCoqXG4gICAqICoqc28gaXQgc2hvdWxkIGJlIHVzZWQgYWZ0ZXIgYW4gZW5naW5lIGNoZWNrKiouXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvSU5URVJPUEVSQUJJTElUWS5tZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaWYgKHRoaXMuc3RvcmFnZU1hcC5iYWNraW5nRW5naW5lID09PSAnbG9jYWxTdG9yYWdlJykge1xuICAgKiAgIGNvbnN0IHsgcHJlZml4IH0gPSB0aGlzLnN0b3JhZ2VNYXAuZmFsbGJhY2tCYWNraW5nU3RvcmU7XG4gICAqIH1cbiAgICovXG4gIGdldCBmYWxsYmFja0JhY2tpbmdTdG9yZSgpOiB7IHByZWZpeDogc3RyaW5nIH0ge1xuXG4gICAgcmV0dXJuICh0aGlzLmRhdGFiYXNlIGluc3RhbmNlb2YgTG9jYWxTdG9yYWdlRGF0YWJhc2UpID9cbiAgICAgIHsgcHJlZml4OiB0aGlzLmRhdGFiYXNlLnByZWZpeCB9IDpcbiAgICAgIHsgcHJlZml4OiAnJyB9O1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICogVGhlIHNpZ25hdHVyZSBoYXMgbWFueSBvdmVybG9hZHMgZHVlIHRvIHZhbGlkYXRpb24sICoqcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uLioqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvYmxvYi9tYWluL2RvY3MvVkFMSURBVElPTi5tZH1cbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhXG4gICAqIEByZXR1cm5zIFRoZSBpdGVtJ3MgdmFsdWUgaWYgdGhlIGtleSBleGlzdHMsIGB1bmRlZmluZWRgIG90aGVyd2lzZSwgd3JhcHBlZCBpbiBhIFJ4SlMgYE9ic2VydmFibGVgXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5nZXQoJ2tleScsIHsgdHlwZTogJ3N0cmluZycgfSkuc3Vic2NyaWJlKChyZXN1bHQpID0+IHtcbiAgICogICByZXN1bHQ7IC8vIHN0cmluZyBvciB1bmRlZmluZWRcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGludGVyZmFjZSBVc2VyIHtcbiAgICogICBmaXJzdE5hbWU6IHN0cmluZztcbiAgICogICBsYXN0TmFtZT86IHN0cmluZztcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBzY2hlbWEgPSB7XG4gICAqICAgdHlwZTogJ29iamVjdCcsXG4gICAqICAgcHJvcGVydGllczoge1xuICAgKiAgICAgZmlyc3ROYW1lOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAqICAgICBsYXN0TmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgKiAgIH0sXG4gICAqICAgcmVxdWlyZWQ6IFsnZmlyc3ROYW1lJ11cbiAgICogfTtcbiAgICpcbiAgICogdGhpcy5zdG9yYWdlTWFwLmdldDxVc2VyPigndXNlcicsIHNjaGVtYSkuc3Vic2NyaWJlKCh1c2VyKSA9PiB7XG4gICAqICAgaWYgKHVzZXIpIHtcbiAgICogICAgIHVzZXIuZmlyc3ROYW1lO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqL1xuICBnZXQoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVua25vd24+O1xuICBnZXQ8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYVN0cmluZyk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUIGV4dGVuZHMgbnVtYmVyID0gbnVtYmVyPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hSW50ZWdlciB8IEpTT05TY2hlbWFOdW1iZXIpOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIGJvb2xlYW4gPSBib29sZWFuPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQm9vbGVhbik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUIGV4dGVuZHMgcmVhZG9ubHkgc3RyaW5nW10gPSBzdHJpbmdbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYVN0cmluZz4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICBnZXQ8VCBleHRlbmRzIHJlYWRvbmx5IG51bWJlcltdID0gbnVtYmVyW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcj4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbiAgZ2V0PFQgZXh0ZW5kcyByZWFkb25seSBib29sZWFuW10gPSBib29sZWFuW10+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFBcnJheU9mPEpTT05TY2hlbWFCb29sZWFuPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIGdldDxUPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgZ2V0PFQgPSB1bmtub3duPihrZXk6IHN0cmluZywgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5rbm93bj4ge1xuXG4gICAgLyogR2V0IHRoZSBkYXRhIGluIHN0b3JhZ2UgKi9cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5nZXQoa2V5KS5waXBlKFxuICAgICAgLyogQ2hlY2sgaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2UuZ2V0KGtleSkpLFxuICAgICAgbWVyZ2VNYXAoKGRhdGEpID0+IHtcblxuICAgICAgICAvKiBObyBuZWVkIHRvIHZhbGlkYXRlIGlmIHRoZSBkYXRhIGlzIGVtcHR5ICovXG4gICAgICAgIGlmICgoZGF0YSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YSA9PT0gbnVsbCkpIHtcblxuICAgICAgICAgIHJldHVybiBvZih1bmRlZmluZWQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hKSB7XG5cbiAgICAgICAgICAvKiBWYWxpZGF0ZSBkYXRhIGFnYWluc3QgYSBKU09OIHNjaGVtYSBpZiBwcm92aWRlZCAqL1xuICAgICAgICAgIGlmICghdGhpcy5qc29uVmFsaWRhdG9yLnZhbGlkYXRlKGRhdGEsIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKG5ldyBWYWxpZGF0aW9uRXJyb3IoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyogRGF0YSBoYXZlIGJlZW4gY2hlY2tlZCwgc28gaXQncyBPSyB0byBjYXN0ICovXG4gICAgICAgICAgcmV0dXJuIG9mKGRhdGEgYXMgVCB8IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENhc3QgdG8gdW5rbm93biBhcyB0aGUgZGF0YSB3YXNuJ3QgY2hlY2tlZCAqL1xuICAgICAgICByZXR1cm4gb2YoZGF0YSk7XG5cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYW4gaXRlbSBpbiBzdG9yYWdlLlxuICAgKiBOb3RlIHRoYXQgc2V0dGluZyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgd2lsbCByZW1vdmUgdGhlIGl0ZW0gdG8gYXZvaWQgc29tZSBicm93c2VycyBpc3N1ZXMuXG4gICAqIEBwYXJhbSBrZXkgVGhlIGl0ZW0ncyBrZXlcbiAgICogQHBhcmFtIGRhdGEgVGhlIGl0ZW0ncyB2YWx1ZVxuICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBkYXRhXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLnNldCgna2V5JywgJ3ZhbHVlJykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIHNldChrZXk6IHN0cmluZywgZGF0YTogdW5rbm93biwgc2NoZW1hPzogSlNPTlNjaGVtYSk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBTdG9yaW5nIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpcyB1c2VsZXNzIGFuZCBjYW4gY2F1c2UgaXNzdWVzIGluIGBpbmRleGVkRGJgIGluIHNvbWUgYnJvd3NlcnMsXG4gICAgICogc28gcmVtb3ZpbmcgaXRlbSBpbnN0ZWFkIGZvciBhbGwgc3RvcmFnZXMgdG8gaGF2ZSBhIGNvbnNpc3RlbnQgQVBJICovXG4gICAgaWYgKChkYXRhID09PSB1bmRlZmluZWQpIHx8IChkYXRhID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgfVxuXG4gICAgLyogVmFsaWRhdGUgZGF0YSBhZ2FpbnN0IGEgSlNPTiBzY2hlbWEgaWYgcHJvdmlkZWQgKi9cbiAgICBpZiAoc2NoZW1hICYmICF0aGlzLmpzb25WYWxpZGF0b3IudmFsaWRhdGUoZGF0YSwgc2NoZW1hKSkge1xuICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IFZhbGlkYXRpb25FcnJvcigpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5zZXQoa2V5LCBkYXRhKS5waXBlKFxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2Uuc2V0KGtleSwgZGF0YSkpLFxuICAgICAgLyogTm90aWZ5IHdhdGNoZXJzIChtdXN0IGJlIGxhc3QgYmVjYXVzZSBpdCBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkcykgKi9cbiAgICAgIHRhcCgoKSA9PiB7IHRoaXMubm90aWZ5KGtleSwgZGF0YSk7IH0pLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGFuIGl0ZW0gaW4gc3RvcmFnZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdGhpcy5zdG9yYWdlTWFwLmRlbGV0ZSgna2V5Jykuc3Vic2NyaWJlKCgpID0+IHt9KTtcbiAgICovXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5kZWxldGUoa2V5KS5waXBlKFxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2UuZGVsZXRlKGtleSkpLFxuICAgICAgLyogTm90aWZ5IHdhdGNoZXJzIChtdXN0IGJlIGxhc3QgYmVjYXVzZSBpdCBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkcykgKi9cbiAgICAgIHRhcCgoKSA9PiB7IHRoaXMubm90aWZ5KGtleSwgdW5kZWZpbmVkKTsgfSksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbGwgaXRlbXMgaW4gc3RvcmFnZVxuICAgKiBAcmV0dXJucyBBIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHRoaXMuc3RvcmFnZU1hcC5jbGVhcigpLnN1YnNjcmliZSgoKSA9PiB7fSk7XG4gICAqL1xuICBjbGVhcigpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2UuY2xlYXIoKS5waXBlKFxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICB0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2UuY2xlYXIoKSksXG4gICAgICAvKiBOb3RpZnkgd2F0Y2hlcnMgKG11c3QgYmUgbGFzdCBiZWNhdXNlIGl0IHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgb3BlcmF0aW9uIHN1Y2NlZWRzKSAqL1xuICAgICAgdGFwKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5ub3RpZmllcnMua2V5cygpKSB7XG4gICAgICAgICAgdGhpcy5ub3RpZnkoa2V5LCB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBrZXlzIHN0b3JlZCBpbiBzdG9yYWdlLiBOb3RlICoqdGhpcyBpcyBhbiAqaXRlcmF0aW5nKiBgT2JzZXJ2YWJsZWAqKjpcbiAgICogKiBpZiB0aGVyZSBpcyBubyBrZXksIHRoZSBgbmV4dGAgY2FsbGJhY2sgd2lsbCBub3QgYmUgaW52b2tlZCxcbiAgICogKiBpZiB5b3UgbmVlZCB0byB3YWl0IHRoZSB3aG9sZSBvcGVyYXRpb24gdG8gZW5kLCBiZSBzdXJlIHRvIGFjdCBpbiB0aGUgYGNvbXBsZXRlYCBjYWxsYmFjayxcbiAgICogYXMgdGhpcyBgT2JzZXJ2YWJsZWAgY2FuIGVtaXQgc2V2ZXJhbCB2YWx1ZXMgYW5kIHNvIHdpbGwgaW52b2tlIHRoZSBgbmV4dGAgY2FsbGJhY2sgc2V2ZXJhbCB0aW1lcy5cbiAgICogQHJldHVybnMgQSBsaXN0IG9mIHRoZSBrZXlzIHdyYXBwZWQgaW4gYSBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAua2V5cygpLnN1YnNjcmliZSh7XG4gICAqICAgbmV4dDogKGtleSkgPT4geyBjb25zb2xlLmxvZyhrZXkpOyB9LFxuICAgKiAgIGNvbXBsZXRlOiAoKSA9PiB7IGNvbnNvbGUubG9nKCdEb25lJyk7IH0sXG4gICAqIH0pO1xuICAgKi9cbiAga2V5cygpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YWJhc2Uua2V5cygpXG4gICAgICAvKiBDYXRjaCBpZiBgaW5kZXhlZERiYCBpcyBicm9rZW4gKi9cbiAgICAgIC5waXBlKHRoaXMuY2F0Y2hJREJCcm9rZW4oKCkgPT4gdGhpcy5kYXRhYmFzZS5rZXlzKCkpKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFRlbGxzIGlmIGEga2V5IGV4aXN0cyBpbiBzdG9yYWdlXG4gICAqIEByZXR1cm5zIEEgUnhKUyBgT2JzZXJ2YWJsZWAgdGVsbGluZyBpZiB0aGUga2V5IGV4aXN0c1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0aGlzLnN0b3JhZ2VNYXAuaGFzKCdrZXknKS5zdWJzY3JpYmUoKGhhc0tleSkgPT4ge1xuICAgKiAgIGlmIChoYXNLZXkpIHt9XG4gICAqIH0pO1xuICAgKi9cbiAgaGFzKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZS5oYXMoa2V5KVxuICAgICAgLyogQ2F0Y2ggaWYgYGluZGV4ZWREYmAgaXMgYnJva2VuICovXG4gICAgICAucGlwZSh0aGlzLmNhdGNoSURCQnJva2VuKCgpID0+IHRoaXMuZGF0YWJhc2UuaGFzKGtleSkpKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIFdhdGNoIGFuIGl0ZW0gdmFsdWUgaW4gc3RvcmFnZS5cbiAgICogKipOb3RlIG9ubHkgY2hhbmdlcyBkb25lIHZpYSB0aGlzIGxpYiB3aWxsIGJlIHdhdGNoZWQqKiwgZXh0ZXJuYWwgY2hhbmdlcyBpbiBzdG9yYWdlIGNhbid0IGJlIGRldGVjdGVkLlxuICAgKiBUaGUgc2lnbmF0dXJlIGhhcyBtYW55IG92ZXJsb2FkcyBkdWUgdG8gdmFsaWRhdGlvbiwgKipwbGVhc2UgcmVmZXIgdG8gdGhlIGRvY3VtZW50YXRpb24uKipcbiAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL1ZBTElEQVRJT04ubWRcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleSB0byB3YXRjaFxuICAgKiBAcGFyYW0gc2NoZW1hIE9wdGlvbmFsIEpTT04gc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBpbml0aWFsIHZhbHVlXG4gICAqIEByZXR1cm5zIEFuIGluZmluaXRlIGBPYnNlcnZhYmxlYCBnaXZpbmcgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICovXG4gIHdhdGNoKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmtub3duPjtcbiAgd2F0Y2g8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYVN0cmluZyk6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyBudW1iZXIgPSBudW1iZXI+KGtleTogc3RyaW5nLCBzY2hlbWE6IEpTT05TY2hlbWFJbnRlZ2VyIHwgSlNPTlNjaGVtYU51bWJlcik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47XG4gIHdhdGNoPFQgZXh0ZW5kcyBib29sZWFuID0gYm9vbGVhbj4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUJvb2xlYW4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICB3YXRjaDxUIGV4dGVuZHMgcmVhZG9ubHkgc3RyaW5nW10gPSBzdHJpbmdbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYVN0cmluZz4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICB3YXRjaDxUIGV4dGVuZHMgcmVhZG9ubHkgbnVtYmVyW10gPSBudW1iZXJbXT4oa2V5OiBzdHJpbmcsIHNjaGVtYTogSlNPTlNjaGVtYUFycmF5T2Y8SlNPTlNjaGVtYUludGVnZXIgfCBKU09OU2NoZW1hTnVtYmVyPik6IE9ic2VydmFibGU8VCB8IHVuZGVmaW5lZD47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxuICB3YXRjaDxUIGV4dGVuZHMgcmVhZG9ubHkgYm9vbGVhbltdID0gYm9vbGVhbltdPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hQXJyYXlPZjxKU09OU2NoZW1hQm9vbGVhbj4pOiBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+O1xuICB3YXRjaDxUPihrZXk6IHN0cmluZywgc2NoZW1hOiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTxUIHwgdW5kZWZpbmVkPjtcbiAgd2F0Y2g8VCA9IHVua25vd24+KGtleTogc3RyaW5nLCBzY2hlbWE/OiBKU09OU2NoZW1hKTogT2JzZXJ2YWJsZTx1bmtub3duPiB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm90aWZpZXIgKi9cbiAgICBpZiAoIXRoaXMubm90aWZpZXJzLmhhcyhrZXkpKSB7XG4gICAgICB0aGlzLm5vdGlmaWVycy5zZXQoa2V5LCBuZXcgUmVwbGF5U3ViamVjdCgxKSk7XG4gICAgfVxuXG4gICAgLyogTm9uLW51bGwgYXNzZXJ0aW9uIGlzIHJlcXVpcmVkIGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IG5hcnJvdyBgLmhhcygpYCB5ZXQgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IG5vdGlmaWVyID0gdGhpcy5ub3RpZmllcnMuZ2V0KGtleSkhO1xuXG4gICAgLyogR2V0IHRoZSBjdXJyZW50IGl0ZW0gdmFsdWUgKi9cbiAgICAoc2NoZW1hID8gdGhpcy5nZXQ8VD4oa2V5LCBzY2hlbWEpIDogdGhpcy5nZXQoa2V5KSkuc3Vic2NyaWJlKHtcbiAgICAgIG5leHQ6IChyZXN1bHQpID0+IG5vdGlmaWVyLm5leHQocmVzdWx0KSxcbiAgICAgIGVycm9yOiAoZXJyb3IpID0+IG5vdGlmaWVyLmVycm9yKGVycm9yKSxcbiAgICB9KTtcblxuICAgIC8qIE9ubHkgdGhlIHB1YmxpYyBBUEkgb2YgdGhlIGBPYnNlcnZhYmxlYCBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgICByZXR1cm4gKHNjaGVtYSA/XG4gICAgICBub3RpZmllci5hc09ic2VydmFibGUoKSBhcyBPYnNlcnZhYmxlPFQgfCB1bmRlZmluZWQ+IDpcbiAgICAgIG5vdGlmaWVyLmFzT2JzZXJ2YWJsZSgpXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmeSB3aGVuIGEgdmFsdWUgY2hhbmdlc1xuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBuZXcgdmFsdWVcbiAgICovXG4gIHByb3RlY3RlZCBub3RpZnkoa2V5OiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKTogdm9pZCB7XG5cbiAgICBjb25zdCBub3RpZmllciA9IHRoaXMubm90aWZpZXJzLmdldChrZXkpO1xuXG4gICAgaWYgKG5vdGlmaWVyKSB7XG4gICAgICBub3RpZmllci5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSeEpTIG9wZXJhdG9yIHRvIGNhdGNoIGlmIGBpbmRleGVkREJgIGlzIGJyb2tlblxuICAgKiBAcGFyYW0gb3BlcmF0aW9uQ2FsbGJhY2sgQ2FsbGJhY2sgd2l0aCB0aGUgb3BlcmF0aW9uIHRvIHJlZG9cbiAgICovXG4gIHByb3RlY3RlZCBjYXRjaElEQkJyb2tlbjxUPihvcGVyYXRpb25DYWxsYmFjazogKCkgPT4gT2JzZXJ2YWJsZTxUPik6IE9wZXJhdG9yRnVuY3Rpb248VCwgVD4ge1xuXG4gICAgcmV0dXJuIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG5cbiAgICAgIC8qIENoZWNrIGlmIGBpbmRleGVkREJgIGlzIGJyb2tlbiBiYXNlZCBvbiBlcnJvciBtZXNzYWdlICh0aGUgc3BlY2lmaWMgZXJyb3IgY2xhc3Mgc2VlbXMgdG8gYmUgbG9zdCBpbiB0aGUgcHJvY2VzcykgKi9cbiAgICAgIGlmICgoZXJyb3IgIT09IHVuZGVmaW5lZCkgJiYgKGVycm9yICE9PSBudWxsKVxuICAgICAgJiYgKHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpICYmICgnbWVzc2FnZScgaW4gZXJyb3IpXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAmJiAoZXJyb3IubWVzc2FnZSA9PT0gSURCX0JST0tFTl9FUlJPUikpIHtcblxuICAgICAgICAvKiBXaGVuIHN0b3JhZ2UgaXMgZnVsbHkgZGlzYWJsZWQgaW4gYnJvd3NlciAodmlhIHRoZSBcIkJsb2NrIGFsbCBjb29raWVzXCIgb3B0aW9uKSxcbiAgICAgICAgICoganVzdCB0cnlpbmcgdG8gY2hlY2sgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgY2F1c2VzIGEgc2VjdXJpdHkgZXhjZXB0aW9uLlxuICAgICAgICAgKiBQcmV2ZW50cyBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy8xMThcbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG5cbiAgICAgICAgICBpZiAoJ2dldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSkge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBgbG9jYWxTdG9yYWdlYCBpZiBhdmFpbGFibGUgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTG9jYWxTdG9yYWdlRGF0YWJhc2UodGhpcy5MU1ByZWZpeCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvKiBGYWxsYmFjayB0byBtZW1vcnkgc3RvcmFnZSBvdGhlcndpc2UgKi9cbiAgICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGNhdGNoIHtcblxuICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIG1lbW9yeSBzdG9yYWdlIG90aGVyd2lzZSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UgPSBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLyogUmVkbyB0aGUgb3BlcmF0aW9uICovXG4gICAgICAgIHJldHVybiBvcGVyYXRpb25DYWxsYmFjaygpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8qIE90aGVyd2lzZSwgcmV0aHJvdyB0aGUgZXJyb3IgKi9cbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IpO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbn1cbiJdfQ==