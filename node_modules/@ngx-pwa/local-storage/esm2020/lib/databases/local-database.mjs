import { Injectable, PLATFORM_ID } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { IDB_STORE_NAME, IDB_DB_NAME, LS_PREFIX, IDB_DB_VERSION, IDB_NO_WRAP } from '../tokens';
import { IndexedDBDatabase } from './indexeddb-database';
import { LocalStorageDatabase } from './localstorage-database';
import { MemoryDatabase } from './memory-database';
import * as i0 from "@angular/core";
/**
 * Factory to create a storage according to browser support
 * @param platformId Context about the platform (`browser`, `server`...)
 * @param LSPrefix Prefix for `localStorage` keys to avoid collision for multiple apps on the same subdomain
 * @param IDBDBName `indexedDB` database name
 * @param IDBstoreName `indexedDB` storeName name
 * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/blob/main/docs/BROWSERS_SUPPORT.md}
 */
export function localDatabaseFactory(platformId, LSPrefix, IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap) {
    /* When storage is fully disabled in browser (via the "Block all cookies" option),
     * just trying to check `indexedDB` or `localStorage` variables causes a security exception.
     * Prevents https://github.com/cyrilletuzi/angular-async-local-storage/issues/118
     */
    try {
        // Do not explicit `window` here, as the global object is not the same in web workers
        if (isPlatformBrowser(platformId) && (indexedDB !== undefined) && (indexedDB !== null) && ('open' in indexedDB)) {
            /* Check:
            * - if we are in a browser context (issue: server-side rendering)
            * - it could exist but be `undefined` or `null`
            * - it could exists but not having a working API
            * Will be the case for:
            * - All other browsers in normal mode
            * - Chromium / Safari private mode, but in this case, data will be swiped when the user leaves the app */
            return new IndexedDBDatabase(IDBDBName, IDBStoreName, IDBDBVersion, IDBNoWrap);
        }
        else if (isPlatformBrowser(platformId)
            && (localStorage !== undefined) && (localStorage !== null) && ('getItem' in localStorage)) {
            /* Check:
            * - if we are in a browser context (issue: server-side rendering)
            * - if `localStorage` exists (to be sure)
            * - it could exists but not having a working API
            * Will be the case for:
            * - Safari cross-origin iframes, detected later in `IndexedDBDatabase.connect()`
            * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42}
            * - Firefox private mode, but in this case, data will be swiped when the user leaves the app
            * For Firefox, can only be detected later in `IndexedDBDatabase.connect()`
            * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}
            */
            return new LocalStorageDatabase(LSPrefix);
        }
    }
    catch {
        // Nothing to do
    }
    /* Will be the case for:
     * - In browsers if storage has been fully disabled (via the "Block all cookies" option)
     * - Server-side rendering
     * - All other non-browser context
     */
    return new MemoryDatabase();
}
export class LocalDatabase {
}
LocalDatabase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: LocalDatabase, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LocalDatabase.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: LocalDatabase, providedIn: 'root', useFactory: localDatabaseFactory, deps: [{ token: PLATFORM_ID }, { token: LS_PREFIX }, { token: IDB_DB_NAME }, { token: IDB_STORE_NAME }, { token: IDB_DB_VERSION }, { token: IDB_NO_WRAP }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: LocalDatabase, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                    useFactory: localDatabaseFactory,
                    deps: [
                        PLATFORM_ID,
                        LS_PREFIX,
                        IDB_DB_NAME,
                        IDB_STORE_NAME,
                        IDB_DB_VERSION,
                        IDB_NO_WRAP,
                    ]
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWwtZGF0YWJhc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcHdhL2xvY2FsLXN0b3JhZ2Uvc3JjL2xpYi9kYXRhYmFzZXMvbG9jYWwtZGF0YWJhc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFHcEQsT0FBTyxFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxXQUFXLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDaEcsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDL0QsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDOztBQUVuRDs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUNsQyxVQUFrQixFQUFFLFFBQWdCLEVBQUUsU0FBaUIsRUFBRSxZQUFvQixFQUM3RSxZQUFvQixFQUFFLFNBQWtCO0lBRXhDOzs7T0FHRztJQUNILElBQUk7UUFFRixxRkFBcUY7UUFDckYsSUFBSSxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sSUFBSSxTQUFTLENBQUMsRUFBRTtZQUUvRzs7Ozs7O3FIQU15RztZQUN6RyxPQUFPLElBQUksaUJBQWlCLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FFaEY7YUFBTSxJQUFJLGlCQUFpQixDQUFDLFVBQVUsQ0FBQztlQUNyQyxDQUFDLFlBQVksS0FBSyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxZQUFZLENBQUMsRUFBRTtZQUV6Rjs7Ozs7Ozs7OztjQVVFO1lBQ0YsT0FBTyxJQUFJLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBRTNDO0tBRUY7SUFBQyxNQUFNO1FBQ04sZ0JBQWdCO0tBQ2pCO0lBRUQ7Ozs7T0FJRztJQUNILE9BQU8sSUFBSSxjQUFjLEVBQUUsQ0FBQztBQUU5QixDQUFDO0FBY0QsTUFBTSxPQUFnQixhQUFhOzswR0FBYixhQUFhOzhHQUFiLGFBQWEsY0FYckIsTUFBTSxjQUNOLG9CQUFvQixrQkFFOUIsV0FBVyxhQUNYLFNBQVMsYUFDVCxXQUFXLGFBQ1gsY0FBYyxhQUNkLGNBQWMsYUFDZCxXQUFXOzJGQUdPLGFBQWE7a0JBWmxDLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07b0JBQ2xCLFVBQVUsRUFBRSxvQkFBb0I7b0JBQ2hDLElBQUksRUFBRTt3QkFDSixXQUFXO3dCQUNYLFNBQVM7d0JBQ1QsV0FBVzt3QkFDWCxjQUFjO3dCQUNkLGNBQWM7d0JBQ2QsV0FBVztxQkFDWjtpQkFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFBMQVRGT1JNX0lEIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IElEQl9TVE9SRV9OQU1FLCBJREJfREJfTkFNRSwgTFNfUFJFRklYLCBJREJfREJfVkVSU0lPTiwgSURCX05PX1dSQVAgfSBmcm9tICcuLi90b2tlbnMnO1xuaW1wb3J0IHsgSW5kZXhlZERCRGF0YWJhc2UgfSBmcm9tICcuL2luZGV4ZWRkYi1kYXRhYmFzZSc7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VEYXRhYmFzZSB9IGZyb20gJy4vbG9jYWxzdG9yYWdlLWRhdGFiYXNlJztcbmltcG9ydCB7IE1lbW9yeURhdGFiYXNlIH0gZnJvbSAnLi9tZW1vcnktZGF0YWJhc2UnO1xuXG4vKipcbiAqIEZhY3RvcnkgdG8gY3JlYXRlIGEgc3RvcmFnZSBhY2NvcmRpbmcgdG8gYnJvd3NlciBzdXBwb3J0XG4gKiBAcGFyYW0gcGxhdGZvcm1JZCBDb250ZXh0IGFib3V0IHRoZSBwbGF0Zm9ybSAoYGJyb3dzZXJgLCBgc2VydmVyYC4uLilcbiAqIEBwYXJhbSBMU1ByZWZpeCBQcmVmaXggZm9yIGBsb2NhbFN0b3JhZ2VgIGtleXMgdG8gYXZvaWQgY29sbGlzaW9uIGZvciBtdWx0aXBsZSBhcHBzIG9uIHRoZSBzYW1lIHN1YmRvbWFpblxuICogQHBhcmFtIElEQkRCTmFtZSBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lXG4gKiBAcGFyYW0gSURCc3RvcmVOYW1lIGBpbmRleGVkREJgIHN0b3JlTmFtZSBuYW1lXG4gKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2Jsb2IvbWFpbi9kb2NzL0JST1dTRVJTX1NVUFBPUlQubWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2NhbERhdGFiYXNlRmFjdG9yeShcbiAgcGxhdGZvcm1JZDogc3RyaW5nLCBMU1ByZWZpeDogc3RyaW5nLCBJREJEQk5hbWU6IHN0cmluZywgSURCU3RvcmVOYW1lOiBzdHJpbmcsXG4gIElEQkRCVmVyc2lvbjogbnVtYmVyLCBJREJOb1dyYXA6IGJvb2xlYW4pOiBMb2NhbERhdGFiYXNlIHtcblxuICAvKiBXaGVuIHN0b3JhZ2UgaXMgZnVsbHkgZGlzYWJsZWQgaW4gYnJvd3NlciAodmlhIHRoZSBcIkJsb2NrIGFsbCBjb29raWVzXCIgb3B0aW9uKSxcbiAgICoganVzdCB0cnlpbmcgdG8gY2hlY2sgYGluZGV4ZWREQmAgb3IgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGVzIGNhdXNlcyBhIHNlY3VyaXR5IGV4Y2VwdGlvbi5cbiAgICogUHJldmVudHMgaHR0cHM6Ly9naXRodWIuY29tL2N5cmlsbGV0dXppL2FuZ3VsYXItYXN5bmMtbG9jYWwtc3RvcmFnZS9pc3N1ZXMvMTE4XG4gICAqL1xuICB0cnkge1xuXG4gICAgLy8gRG8gbm90IGV4cGxpY2l0IGB3aW5kb3dgIGhlcmUsIGFzIHRoZSBnbG9iYWwgb2JqZWN0IGlzIG5vdCB0aGUgc2FtZSBpbiB3ZWIgd29ya2Vyc1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3NlcihwbGF0Zm9ybUlkKSAmJiAoaW5kZXhlZERCICE9PSB1bmRlZmluZWQpICYmIChpbmRleGVkREIgIT09IG51bGwpICYmICgnb3BlbicgaW4gaW5kZXhlZERCKSkge1xuXG4gICAgICAvKiBDaGVjazpcbiAgICAgICogLSBpZiB3ZSBhcmUgaW4gYSBicm93c2VyIGNvbnRleHQgKGlzc3VlOiBzZXJ2ZXItc2lkZSByZW5kZXJpbmcpXG4gICAgICAqIC0gaXQgY291bGQgZXhpc3QgYnV0IGJlIGB1bmRlZmluZWRgIG9yIGBudWxsYFxuICAgICAgKiAtIGl0IGNvdWxkIGV4aXN0cyBidXQgbm90IGhhdmluZyBhIHdvcmtpbmcgQVBJXG4gICAgICAqIFdpbGwgYmUgdGhlIGNhc2UgZm9yOlxuICAgICAgKiAtIEFsbCBvdGhlciBicm93c2VycyBpbiBub3JtYWwgbW9kZVxuICAgICAgKiAtIENocm9taXVtIC8gU2FmYXJpIHByaXZhdGUgbW9kZSwgYnV0IGluIHRoaXMgY2FzZSwgZGF0YSB3aWxsIGJlIHN3aXBlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGUgYXBwICovXG4gICAgICByZXR1cm4gbmV3IEluZGV4ZWREQkRhdGFiYXNlKElEQkRCTmFtZSwgSURCU3RvcmVOYW1lLCBJREJEQlZlcnNpb24sIElEQk5vV3JhcCk7XG5cbiAgICB9IGVsc2UgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpXG4gICAgJiYgKGxvY2FsU3RvcmFnZSAhPT0gdW5kZWZpbmVkKSAmJiAobG9jYWxTdG9yYWdlICE9PSBudWxsKSAmJiAoJ2dldEl0ZW0nIGluIGxvY2FsU3RvcmFnZSkpIHtcblxuICAgICAgLyogQ2hlY2s6XG4gICAgICAqIC0gaWYgd2UgYXJlIGluIGEgYnJvd3NlciBjb250ZXh0IChpc3N1ZTogc2VydmVyLXNpZGUgcmVuZGVyaW5nKVxuICAgICAgKiAtIGlmIGBsb2NhbFN0b3JhZ2VgIGV4aXN0cyAodG8gYmUgc3VyZSlcbiAgICAgICogLSBpdCBjb3VsZCBleGlzdHMgYnV0IG5vdCBoYXZpbmcgYSB3b3JraW5nIEFQSVxuICAgICAgKiBXaWxsIGJlIHRoZSBjYXNlIGZvcjpcbiAgICAgICogLSBTYWZhcmkgY3Jvc3Mtb3JpZ2luIGlmcmFtZXMsIGRldGVjdGVkIGxhdGVyIGluIGBJbmRleGVkREJEYXRhYmFzZS5jb25uZWN0KClgXG4gICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzQyfVxuICAgICAgKiAtIEZpcmVmb3ggcHJpdmF0ZSBtb2RlLCBidXQgaW4gdGhpcyBjYXNlLCBkYXRhIHdpbGwgYmUgc3dpcGVkIHdoZW4gdGhlIHVzZXIgbGVhdmVzIHRoZSBhcHBcbiAgICAgICogRm9yIEZpcmVmb3gsIGNhbiBvbmx5IGJlIGRldGVjdGVkIGxhdGVyIGluIGBJbmRleGVkREJEYXRhYmFzZS5jb25uZWN0KClgXG4gICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc4MTk4Mn1cbiAgICAgICovXG4gICAgICByZXR1cm4gbmV3IExvY2FsU3RvcmFnZURhdGFiYXNlKExTUHJlZml4KTtcblxuICAgIH1cblxuICB9IGNhdGNoIHtcbiAgICAvLyBOb3RoaW5nIHRvIGRvXG4gIH1cblxuICAvKiBXaWxsIGJlIHRoZSBjYXNlIGZvcjpcbiAgICogLSBJbiBicm93c2VycyBpZiBzdG9yYWdlIGhhcyBiZWVuIGZ1bGx5IGRpc2FibGVkICh2aWEgdGhlIFwiQmxvY2sgYWxsIGNvb2tpZXNcIiBvcHRpb24pXG4gICAqIC0gU2VydmVyLXNpZGUgcmVuZGVyaW5nXG4gICAqIC0gQWxsIG90aGVyIG5vbi1icm93c2VyIGNvbnRleHRcbiAgICovXG4gIHJldHVybiBuZXcgTWVtb3J5RGF0YWJhc2UoKTtcblxufVxuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290JyxcbiAgdXNlRmFjdG9yeTogbG9jYWxEYXRhYmFzZUZhY3RvcnksXG4gIGRlcHM6IFtcbiAgICBQTEFURk9STV9JRCxcbiAgICBMU19QUkVGSVgsXG4gICAgSURCX0RCX05BTUUsXG4gICAgSURCX1NUT1JFX05BTUUsXG4gICAgSURCX0RCX1ZFUlNJT04sXG4gICAgSURCX05PX1dSQVAsXG4gIF1cbn0pXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTG9jYWxEYXRhYmFzZSB7XG5cbiAgYWJzdHJhY3QgcmVhZG9ubHkgc2l6ZTogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4gIGFic3RyYWN0IGdldChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5rbm93biB8IHVuZGVmaW5lZD47XG4gIGFic3RyYWN0IHNldChrZXk6IHN0cmluZywgZGF0YTogdW5rbm93bik6IE9ic2VydmFibGU8dW5kZWZpbmVkPjtcbiAgYWJzdHJhY3QgZGVsZXRlKGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTx1bmRlZmluZWQ+O1xuICBhYnN0cmFjdCBjbGVhcigpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD47XG4gIGFic3RyYWN0IGtleXMoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICBhYnN0cmFjdCBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuXG59XG4iXX0=