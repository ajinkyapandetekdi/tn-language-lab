import { Injectable, Inject } from '@angular/core';
import { ReplaySubject, fromEvent, of, throwError, race } from 'rxjs';
import { map, mergeMap, first, takeWhile, tap, mapTo } from 'rxjs/operators';
import { IDB_DB_NAME, IDB_STORE_NAME, DEFAULT_IDB_STORE_NAME, IDB_DB_VERSION, DEFAULT_IDB_DB_NAME, DEFAULT_IDB_DB_VERSION, IDB_NO_WRAP, DEFAULT_IDB_NO_WRAP } from '../tokens';
import { IDBBrokenError } from './exceptions';
import * as i0 from "@angular/core";
export class IndexedDBDatabase {
    /**
     * Constructor params are provided by Angular (but can also be passed manually in tests)
     * @param dbName `indexedDB` database name
     * @param storeName `indexedDB` store name
     * @param dbVersion `indexedDB` database version
     * @param noWrap Flag to not wrap `indexedDB` values for interoperability or to wrap for backward compatibility
     */
    constructor(dbName = DEFAULT_IDB_DB_NAME, storeName = DEFAULT_IDB_STORE_NAME, dbVersion = DEFAULT_IDB_DB_VERSION, noWrap = DEFAULT_IDB_NO_WRAP) {
        /**
         * `indexedDB` database connection, wrapped in a RxJS `ReplaySubject` to be able to access the connection
         * even after the connection success event happened
         */
        this.database = new ReplaySubject(1);
        /**
         * Index used when wrapping value. *For backward compatibility only.*
         */
        this.wrapIndex = 'value';
        this.dbName = dbName;
        this.storeName = storeName;
        this.dbVersion = dbVersion;
        this.noWrap = noWrap;
        /* Connect to `indexedDB`, with prefix if provided by the user */
        this.connect();
    }
    /**
     * Information about `indexedDB` connection. *Only useful for interoperability.*
     * @returns `indexedDB` database name, store name and database version
     */
    get backingStore() {
        return {
            database: this.dbName,
            store: this.storeName,
            version: this.dbVersion,
        };
    }
    /**
     * Number of items in our `indexedDB` database and object store
     */
    get size() {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request to know the number of items */
            const request = store.count();
            /* Return the result */
            return events.pipe(map(() => request.result));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Gets an item value in our `indexedDB` store
     * @param key The item's key
     * @returns The item's value if the key exists, `undefined` otherwise, wrapped in an RxJS `Observable`
     */
    get(key) {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Request the value with the key provided by the user */
            const request = store.get(key);
            /* Listen events and return the result */
            return events.pipe(map(() => {
                if ((request.result !== undefined) && (request.result !== null)) {
                    /* Prior to v8, the value was wrapped in an `{ value: ...}` object */
                    if (!this.noWrap && (typeof request.result === 'object') && (this.wrapIndex in request.result) &&
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        (request.result[this.wrapIndex] !== undefined) && (request.result[this.wrapIndex] !== null)) {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                        return request.result[this.wrapIndex];
                    }
                    else {
                        /* Cast to the wanted type */
                        return request.result;
                    }
                }
                /* Return `undefined` if the value is empty */
                return undefined;
            }));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Sets an item in our `indexedDB` store
     * @param key The item's key
     * @param data The item's value
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    set(key, data) {
        /* Storing `undefined` in `indexedDb` can cause issues in some browsers so removing item instead */
        if (data === undefined) {
            return this.delete(key);
        }
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Prior to v8, data was wrapped in a `{ value: ... }` object */
            const dataToStore = this.noWrap ? data : { [this.wrapIndex]: data };
            /* Add if the item is not existing yet, or update otherwise */
            store.put(dataToStore, key);
            /* Listen to events and return `undefined` as no value is expected */
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return events.pipe(mapTo(undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes an item in our `indexedDB` store
     * @param key The item's key
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    delete(key) {
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete the item in store */
            store.delete(key);
            /* Listen to events and return `undefined` as no data is expected here */
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return events.pipe(mapTo(undefined));
        }), 
        /* The observable will complete after the first value */
        first());
    }
    /**
     * Deletes all items from our `indexedDB` objet store
     * @returns An RxJS `Observable` to wait the end of the operation
     */
    clear() {
        /* Open a transaction in write mode */
        return this.transaction('readwrite').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Delete all items in object store */
            store.clear();
            /* Listen to events and return `undefined` as no data is expected here */
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            return events.pipe(mapTo(undefined));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Get all the keys in our `indexedDB` store
     * @returns An RxJS `Observable` iterating on each key
     */
    keys() {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(
        /* `first()` is used as the final operator in other methods to complete the `Observable`
         * (as it all starts from a `ReplaySubject` which never ends),
         * but as this method is iterating over multiple values, `first()` **must** be used here */
        first(), mergeMap((transactionData) => {
            const { store } = transactionData;
            /* Open a cursor on the store
             * Avoid issues like https://github.com/cyrilletuzi/angular-async-local-storage/issues/69 */
            const request = store.openKeyCursor();
            /* Listen to success event */
            const success$ = fromEvent(request, 'success').pipe(
            /* Stop the `Observable` when the cursor is `null` */
            takeWhile(() => (request.result !== null)), 
            /* This lib only allows string keys, but user could have added other types of keys from outside
             * It's OK to cast as the cursor as been tested in the previous operator */
            map(() => request.result.key.toString()), 
            /* Iterate on the cursor */
            tap(() => { request.result.continue(); }));
            /* Listen to error event and if so, throw an error */
            const error$ = this.listenError(request);
            /* Choose the first event to occur */
            return race([success$, error$]);
        }));
    }
    /**
     * Check if a key exists in our `indexedDB` store
     * @returns An RxJS `Observable` telling if the key exists or not
     */
    has(key) {
        /* Open a transaction in read-only mode */
        return this.transaction('readonly').pipe(mergeMap((transactionData) => {
            const { store, events } = transactionData;
            /* Check if the key exists in the store
             * Fixes https://github.com/cyrilletuzi/angular-async-local-storage/issues/69
             */
            const request = store.getKey(key);
            /* Listen to events and return `true` or `false` */
            return events.pipe(map(() => (request.result !== undefined) ? true : false));
        }), 
        /* The observable will complete */
        first());
    }
    /**
     * Connects to `indexedDB` and creates the object store on first time
     */
    connect() {
        let request;
        /* Connect to `indexedDB`
         * Will fail in Safari cross-origin iframes
         * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/42} */
        try {
            /* Do NOT explicit `window` here, as `indexedDB` could be used from a web worker too */
            request = indexedDB.open(this.dbName, this.dbVersion);
        }
        catch {
            this.database.error(new IDBBrokenError());
            return;
        }
        /* Create store on first connection */
        this.createStore(request);
        /* Listen to success and error events */
        const success$ = fromEvent(request, 'success');
        const error$ = this.listenError(request);
        /* Choose the first to occur */
        race([success$, error$])
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Register the database connection in the `ReplaySubject` for further access */
                this.database.next(request.result);
            },
            error: () => {
                /* Firefox private mode issue: fallback storage if IndexedDb connection is failing
                * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=781982}
                * @see {@link https://github.com/cyrilletuzi/angular-async-local-storage/issues/26} */
                this.database.error(new IDBBrokenError());
            },
        });
    }
    /**
     * Create store on first use of `indexedDB`
     * @param request `indexedDB` database opening request
     */
    createStore(request) {
        /* Listen to the event fired on first connection */
        fromEvent(request, 'upgradeneeded')
            /* The observable will complete */
            .pipe(first())
            .subscribe({
            next: () => {
                /* Check if the store already exists, to avoid error */
                if (!request.result.objectStoreNames.contains(this.storeName)) {
                    /* Create the object store */
                    request.result.createObjectStore(this.storeName);
                }
            }
        });
    }
    /**
     * Open an `indexedDB` transaction and get our store
     * @param mode `readonly` or `readwrite`
     * @returns An `indexedDB` transaction store and events, wrapped in an RxJS `Observable`
     */
    transaction(mode) {
        /* From the `indexedDB` connection, open a transaction and get the store */
        return this.database
            .pipe(mergeMap((database) => {
            let transaction;
            try {
                transaction = database.transaction([this.storeName], mode);
            }
            catch (error) {
                /* The store could have been deleted from outside */
                return throwError(error);
            }
            /* Get the store from the transaction */
            const store = transaction.objectStore(this.storeName);
            /* Listen transaction `complete` and `error` events */
            const events = this.listenTransactionEvents(transaction);
            return of({ store, events });
        }));
    }
    /**
     * Listen errors on a transaction or request, and throw if trigerred
     * @param transactionOrRequest `indexedDb` transaction or request to listen
     * @returns An `Observable` listening to errors
     */
    listenError(transactionOrRequest) {
        return fromEvent(transactionOrRequest, 'error').pipe(
        /* Throw on error to be able to catch errors in RxJS way.
         * Here `event.target` must be used, as `transactionOrRequest.error` will be `null`
         * if we are on the request and the error is only triggered later by the transaction */
        mergeMap((event) => throwError(event.target.error)));
    }
    /**
     * Listen transaction `complete` and `error` events
     * @param transaction Transaction to listen
     * @returns An `Observable` listening to transaction `complete` and `error` events
     */
    listenTransactionEvents(transaction) {
        /* Listen to the `complete` event */
        const complete$ = fromEvent(transaction, 'complete');
        /* Listen to the `error` event */
        const error$ = this.listenError(transaction);
        /* Choose the first event to occur */
        return race([complete$, error$]);
    }
}
IndexedDBDatabase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: IndexedDBDatabase, deps: [{ token: IDB_DB_NAME }, { token: IDB_STORE_NAME }, { token: IDB_DB_VERSION }, { token: IDB_NO_WRAP }], target: i0.ɵɵFactoryTarget.Injectable });
IndexedDBDatabase.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: IndexedDBDatabase, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.3", ngImport: i0, type: IndexedDBDatabase, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IDB_DB_NAME]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IDB_STORE_NAME]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IDB_DB_VERSION]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IDB_NO_WRAP]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXhlZGRiLWRhdGFiYXNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXB3YS9sb2NhbC1zdG9yYWdlL3NyYy9saWIvZGF0YWJhc2VzL2luZGV4ZWRkYi1kYXRhYmFzZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQWMsYUFBYSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRixPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU3RSxPQUFPLEVBQ0wsV0FBVyxFQUFFLGNBQWMsRUFBRSxzQkFBc0IsRUFBRSxjQUFjLEVBQ25FLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLFdBQVcsRUFBRSxtQkFBbUIsRUFDOUUsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7QUFNOUMsTUFBTSxPQUFPLGlCQUFpQjtJQWlDNUI7Ozs7OztPQU1HO0lBQ0gsWUFDdUIsTUFBTSxHQUFHLG1CQUFtQixFQUN6QixTQUFTLEdBQUcsc0JBQXNCLEVBQ2xDLFNBQVMsR0FBRyxzQkFBc0IsRUFDckMsTUFBTSxHQUFHLG1CQUFtQjtRQTNCbkQ7OztXQUdHO1FBQ2dCLGFBQVEsR0FBRyxJQUFJLGFBQWEsQ0FBYyxDQUFDLENBQUMsQ0FBQztRQU9oRTs7V0FFRztRQUNnQixjQUFTLEdBQUcsT0FBTyxDQUFDO1FBZ0JyQyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsU0FB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LFVBQVUsQ0FBQyxDQUFDO1FBRXJELGlDQUFpQztRQUNqQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTdDLHFDQUFxQztRQUNyQyxPQUFPLElBQUksQ0FBQyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBRW5DLENBQUM7OzhHQWpjVSxpQkFBaUIsa0JBeUNsQixXQUFXLGFBQ1gsY0FBYyxhQUNkLGNBQWMsYUFDZCxXQUFXO2tIQTVDVixpQkFBaUIsY0FGaEIsTUFBTTsyRkFFUCxpQkFBaUI7a0JBSDdCLFVBQVU7bUJBQUM7b0JBQ1YsVUFBVSxFQUFFLE1BQU07aUJBQ25COzswQkEwQ0ksTUFBTTsyQkFBQyxXQUFXOzswQkFDbEIsTUFBTTsyQkFBQyxjQUFjOzswQkFDckIsTUFBTTsyQkFBQyxjQUFjOzswQkFDckIsTUFBTTsyQkFBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCBmcm9tRXZlbnQsIG9mLCB0aHJvd0Vycm9yLCByYWNlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAsIG1lcmdlTWFwLCBmaXJzdCwgdGFrZVdoaWxlLCB0YXAsIG1hcFRvIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQge1xuICBJREJfREJfTkFNRSwgSURCX1NUT1JFX05BTUUsIERFRkFVTFRfSURCX1NUT1JFX05BTUUsIElEQl9EQl9WRVJTSU9OLFxuICBERUZBVUxUX0lEQl9EQl9OQU1FLCBERUZBVUxUX0lEQl9EQl9WRVJTSU9OLCBJREJfTk9fV1JBUCwgREVGQVVMVF9JREJfTk9fV1JBUFxufSBmcm9tICcuLi90b2tlbnMnO1xuaW1wb3J0IHsgSURCQnJva2VuRXJyb3IgfSBmcm9tICcuL2V4Y2VwdGlvbnMnO1xuaW1wb3J0IHsgTG9jYWxEYXRhYmFzZSB9IGZyb20gJy4vbG9jYWwtZGF0YWJhc2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBJbmRleGVkREJEYXRhYmFzZSBpbXBsZW1lbnRzIExvY2FsRGF0YWJhc2Uge1xuXG4gIC8qKlxuICAgKiBgaW5kZXhlZERCYCBkYXRhYmFzZSBuYW1lXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGJOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGBpbmRleGVkREJgIG9iamVjdCBzdG9yZSBuYW1lXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc3RvcmVOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIGBpbmRleGVkREJgIGRhdGFiYXNlIHZlcnNpb24uIE11c3QgYmUgYW4gdW5zaWduZWQgKippbnRlZ2VyKipcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBkYlZlcnNpb246IG51bWJlcjtcblxuICAvKipcbiAgICogYGluZGV4ZWREQmAgZGF0YWJhc2UgY29ubmVjdGlvbiwgd3JhcHBlZCBpbiBhIFJ4SlMgYFJlcGxheVN1YmplY3RgIHRvIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBjb25uZWN0aW9uXG4gICAqIGV2ZW4gYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gc3VjY2VzcyBldmVudCBoYXBwZW5lZFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFiYXNlID0gbmV3IFJlcGxheVN1YmplY3Q8SURCRGF0YWJhc2U+KDEpO1xuXG4gIC8qKlxuICAgKiBGbGFnIHRvIG5vdCB3cmFwIGBpbmRleGVkREJgIHZhbHVlcyBmb3IgaW50ZXJvcGVyYWJpbGl0eSBvciB0byB3cmFwIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IG5vV3JhcDogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5kZXggdXNlZCB3aGVuIHdyYXBwaW5nIHZhbHVlLiAqRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgb25seS4qXG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgd3JhcEluZGV4ID0gJ3ZhbHVlJztcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgcGFyYW1zIGFyZSBwcm92aWRlZCBieSBBbmd1bGFyIChidXQgY2FuIGFsc28gYmUgcGFzc2VkIG1hbnVhbGx5IGluIHRlc3RzKVxuICAgKiBAcGFyYW0gZGJOYW1lIGBpbmRleGVkREJgIGRhdGFiYXNlIG5hbWVcbiAgICogQHBhcmFtIHN0b3JlTmFtZSBgaW5kZXhlZERCYCBzdG9yZSBuYW1lXG4gICAqIEBwYXJhbSBkYlZlcnNpb24gYGluZGV4ZWREQmAgZGF0YWJhc2UgdmVyc2lvblxuICAgKiBAcGFyYW0gbm9XcmFwIEZsYWcgdG8gbm90IHdyYXAgYGluZGV4ZWREQmAgdmFsdWVzIGZvciBpbnRlcm9wZXJhYmlsaXR5IG9yIHRvIHdyYXAgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBJbmplY3QoSURCX0RCX05BTUUpIGRiTmFtZSA9IERFRkFVTFRfSURCX0RCX05BTUUsXG4gICAgQEluamVjdChJREJfU1RPUkVfTkFNRSkgc3RvcmVOYW1lID0gREVGQVVMVF9JREJfU1RPUkVfTkFNRSxcbiAgICBASW5qZWN0KElEQl9EQl9WRVJTSU9OKSBkYlZlcnNpb24gPSBERUZBVUxUX0lEQl9EQl9WRVJTSU9OLFxuICAgIEBJbmplY3QoSURCX05PX1dSQVApIG5vV3JhcCA9IERFRkFVTFRfSURCX05PX1dSQVAsXG4gICkge1xuXG4gICAgdGhpcy5kYk5hbWUgPSBkYk5hbWU7XG4gICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG4gICAgdGhpcy5kYlZlcnNpb24gPSBkYlZlcnNpb247XG4gICAgdGhpcy5ub1dyYXAgPSBub1dyYXA7XG5cbiAgICAvKiBDb25uZWN0IHRvIGBpbmRleGVkREJgLCB3aXRoIHByZWZpeCBpZiBwcm92aWRlZCBieSB0aGUgdXNlciAqL1xuICAgIHRoaXMuY29ubmVjdCgpO1xuXG4gIH1cblxuICAvKipcbiAgICogSW5mb3JtYXRpb24gYWJvdXQgYGluZGV4ZWREQmAgY29ubmVjdGlvbi4gKk9ubHkgdXNlZnVsIGZvciBpbnRlcm9wZXJhYmlsaXR5LipcbiAgICogQHJldHVybnMgYGluZGV4ZWREQmAgZGF0YWJhc2UgbmFtZSwgc3RvcmUgbmFtZSBhbmQgZGF0YWJhc2UgdmVyc2lvblxuICAgKi9cbiAgZ2V0IGJhY2tpbmdTdG9yZSgpOiB7IGRhdGFiYXNlOiBzdHJpbmcsIHN0b3JlOiBzdHJpbmcsIHZlcnNpb246IG51bWJlciB9IHtcblxuICAgIHJldHVybiB7XG4gICAgICBkYXRhYmFzZTogdGhpcy5kYk5hbWUsXG4gICAgICBzdG9yZTogdGhpcy5zdG9yZU5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLmRiVmVyc2lvbixcbiAgICB9O1xuXG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGl0ZW1zIGluIG91ciBgaW5kZXhlZERCYCBkYXRhYmFzZSBhbmQgb2JqZWN0IHN0b3JlXG4gICAqL1xuICBnZXQgc2l6ZSgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBSZXF1ZXN0IHRvIGtub3cgdGhlIG51bWJlciBvZiBpdGVtcyAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuY291bnQoKTtcblxuICAgICAgICAvKiBSZXR1cm4gdGhlIHJlc3VsdCAqL1xuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwKCgpID0+IHJlcXVlc3QucmVzdWx0KSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhZnRlciB0aGUgZmlyc3QgdmFsdWUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gaXRlbSB2YWx1ZSBpbiBvdXIgYGluZGV4ZWREQmAgc3RvcmVcbiAgICogQHBhcmFtIGtleSBUaGUgaXRlbSdzIGtleVxuICAgKiBAcmV0dXJucyBUaGUgaXRlbSdzIHZhbHVlIGlmIHRoZSBrZXkgZXhpc3RzLCBgdW5kZWZpbmVkYCBvdGhlcndpc2UsIHdyYXBwZWQgaW4gYW4gUnhKUyBgT2JzZXJ2YWJsZWBcbiAgICovXG4gIGdldChrZXk6IHN0cmluZyk6IE9ic2VydmFibGU8dW5rbm93biB8IHVuZGVmaW5lZD4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBSZXF1ZXN0IHRoZSB2YWx1ZSB3aXRoIHRoZSBrZXkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgKi9cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHN0b3JlLmdldChrZXkpO1xuXG4gICAgICAgIC8qIExpc3RlbiBldmVudHMgYW5kIHJldHVybiB0aGUgcmVzdWx0ICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXAoKCk6IHVua25vd24gPT4ge1xuXG4gICAgICAgICAgaWYgKChyZXF1ZXN0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSAmJiAocmVxdWVzdC5yZXN1bHQgIT09IG51bGwpKSB7XG5cbiAgICAgICAgICAgIC8qIFByaW9yIHRvIHY4LCB0aGUgdmFsdWUgd2FzIHdyYXBwZWQgaW4gYW4gYHsgdmFsdWU6IC4uLn1gIG9iamVjdCAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5vV3JhcCAmJiAodHlwZW9mIHJlcXVlc3QucmVzdWx0ID09PSAnb2JqZWN0JykgJiYgKHRoaXMud3JhcEluZGV4IGluIHJlcXVlc3QucmVzdWx0KSAmJlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2Vzc1xuICAgICAgICAgICAgKHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XSAhPT0gdW5kZWZpbmVkKSAmJiAocmVxdWVzdC5yZXN1bHRbdGhpcy53cmFwSW5kZXhdICE9PSBudWxsKSkge1xuXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucmVzdWx0W3RoaXMud3JhcEluZGV4XTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvKiBDYXN0IHRvIHRoZSB3YW50ZWQgdHlwZSAqL1xuICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5yZXN1bHQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIFJldHVybiBgdW5kZWZpbmVkYCBpZiB0aGUgdmFsdWUgaXMgZW1wdHkgKi9cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICAgIH0pKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBpdGVtIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEBwYXJhbSBkYXRhIFRoZSBpdGVtJ3MgdmFsdWVcbiAgICogQHJldHVybnMgQW4gUnhKUyBgT2JzZXJ2YWJsZWAgdG8gd2FpdCB0aGUgZW5kIG9mIHRoZSBvcGVyYXRpb25cbiAgICovXG4gIHNldChrZXk6IHN0cmluZywgZGF0YTogdW5rbm93bik6IE9ic2VydmFibGU8dW5kZWZpbmVkPiB7XG5cbiAgICAvKiBTdG9yaW5nIGB1bmRlZmluZWRgIGluIGBpbmRleGVkRGJgIGNhbiBjYXVzZSBpc3N1ZXMgaW4gc29tZSBicm93c2VycyBzbyByZW1vdmluZyBpdGVtIGluc3RlYWQgKi9cbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICB9XG5cbiAgICAvKiBPcGVuIGEgdHJhbnNhY3Rpb24gaW4gd3JpdGUgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnKS5waXBlKFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUsIGV2ZW50cyB9ID0gdHJhbnNhY3Rpb25EYXRhO1xuXG4gICAgICAgIC8qIFByaW9yIHRvIHY4LCBkYXRhIHdhcyB3cmFwcGVkIGluIGEgYHsgdmFsdWU6IC4uLiB9YCBvYmplY3QgKi9cbiAgICAgICAgY29uc3QgZGF0YVRvU3RvcmUgPSB0aGlzLm5vV3JhcCA/IGRhdGEgOiB7IFt0aGlzLndyYXBJbmRleF06IGRhdGEgfTtcblxuICAgICAgICAvKiBBZGQgaWYgdGhlIGl0ZW0gaXMgbm90IGV4aXN0aW5nIHlldCwgb3IgdXBkYXRlIG90aGVyd2lzZSAqL1xuICAgICAgICBzdG9yZS5wdXQoZGF0YVRvU3RvcmUsIGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGV2ZW50cyBhbmQgcmV0dXJuIGB1bmRlZmluZWRgIGFzIG5vIHZhbHVlIGlzIGV4cGVjdGVkICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXBUbyh1bmRlZmluZWQpKTtcblxuICAgICAgfSksXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlIGFmdGVyIHRoZSBmaXJzdCB2YWx1ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBpdGVtIGluIG91ciBgaW5kZXhlZERCYCBzdG9yZVxuICAgKiBAcGFyYW0ga2V5IFRoZSBpdGVtJ3Mga2V5XG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBkZWxldGUoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHdyaXRlIG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBEZWxldGUgdGhlIGl0ZW0gaW4gc3RvcmUgKi9cbiAgICAgICAgc3RvcmUuZGVsZXRlKGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGV2ZW50cyBhbmQgcmV0dXJuIGB1bmRlZmluZWRgIGFzIG5vIGRhdGEgaXMgZXhwZWN0ZWQgaGVyZSAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICByZXR1cm4gZXZlbnRzLnBpcGUobWFwVG8odW5kZWZpbmVkKSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSBhZnRlciB0aGUgZmlyc3QgdmFsdWUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGl0ZW1zIGZyb20gb3VyIGBpbmRleGVkREJgIG9iamV0IHN0b3JlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRvIHdhaXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uXG4gICAqL1xuICBjbGVhcigpOiBPYnNlcnZhYmxlPHVuZGVmaW5lZD4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHdyaXRlIG1vZGUgKi9cbiAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbigncmVhZHdyaXRlJykucGlwZShcbiAgICAgIG1lcmdlTWFwKCh0cmFuc2FjdGlvbkRhdGEpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN0b3JlLCBldmVudHMgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBEZWxldGUgYWxsIGl0ZW1zIGluIG9iamVjdCBzdG9yZSAqL1xuICAgICAgICBzdG9yZS5jbGVhcigpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBldmVudHMgYW5kIHJldHVybiBgdW5kZWZpbmVkYCBhcyBubyBkYXRhIGlzIGV4cGVjdGVkIGhlcmUgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnRcbiAgICAgICAgcmV0dXJuIGV2ZW50cy5waXBlKG1hcFRvKHVuZGVmaW5lZCkpO1xuXG4gICAgICB9KSxcbiAgICAgIC8qIFRoZSBvYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgKi9cbiAgICAgIGZpcnN0KCksXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdGhlIGtleXMgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIGl0ZXJhdGluZyBvbiBlYWNoIGtleVxuICAgKi9cbiAga2V5cygpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXG4gICAgLyogT3BlbiBhIHRyYW5zYWN0aW9uIGluIHJlYWQtb25seSBtb2RlICovXG4gICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb24oJ3JlYWRvbmx5JykucGlwZShcbiAgICAgIC8qIGBmaXJzdCgpYCBpcyB1c2VkIGFzIHRoZSBmaW5hbCBvcGVyYXRvciBpbiBvdGhlciBtZXRob2RzIHRvIGNvbXBsZXRlIHRoZSBgT2JzZXJ2YWJsZWBcbiAgICAgICAqIChhcyBpdCBhbGwgc3RhcnRzIGZyb20gYSBgUmVwbGF5U3ViamVjdGAgd2hpY2ggbmV2ZXIgZW5kcyksXG4gICAgICAgKiBidXQgYXMgdGhpcyBtZXRob2QgaXMgaXRlcmF0aW5nIG92ZXIgbXVsdGlwbGUgdmFsdWVzLCBgZmlyc3QoKWAgKiptdXN0KiogYmUgdXNlZCBoZXJlICovXG4gICAgICBmaXJzdCgpLFxuICAgICAgbWVyZ2VNYXAoKHRyYW5zYWN0aW9uRGF0YSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHsgc3RvcmUgfSA9IHRyYW5zYWN0aW9uRGF0YTtcblxuICAgICAgICAvKiBPcGVuIGEgY3Vyc29yIG9uIHRoZSBzdG9yZVxuICAgICAgICAgKiBBdm9pZCBpc3N1ZXMgbGlrZSBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy82OSAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUub3BlbktleUN1cnNvcigpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0byBzdWNjZXNzIGV2ZW50ICovXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MkID0gZnJvbUV2ZW50KHJlcXVlc3QsICdzdWNjZXNzJykucGlwZShcbiAgICAgICAgICAvKiBTdG9wIHRoZSBgT2JzZXJ2YWJsZWAgd2hlbiB0aGUgY3Vyc29yIGlzIGBudWxsYCAqL1xuICAgICAgICAgIHRha2VXaGlsZSgoKSA9PiAocmVxdWVzdC5yZXN1bHQgIT09IG51bGwpKSxcbiAgICAgICAgICAvKiBUaGlzIGxpYiBvbmx5IGFsbG93cyBzdHJpbmcga2V5cywgYnV0IHVzZXIgY291bGQgaGF2ZSBhZGRlZCBvdGhlciB0eXBlcyBvZiBrZXlzIGZyb20gb3V0c2lkZVxuICAgICAgICAgICAqIEl0J3MgT0sgdG8gY2FzdCBhcyB0aGUgY3Vyc29yIGFzIGJlZW4gdGVzdGVkIGluIHRoZSBwcmV2aW91cyBvcGVyYXRvciAqL1xuICAgICAgICAgIG1hcCgoKSA9PiAocmVxdWVzdC5yZXN1bHQgYXMgSURCQ3Vyc29yKS5rZXkudG9TdHJpbmcoKSksXG4gICAgICAgICAgLyogSXRlcmF0ZSBvbiB0aGUgY3Vyc29yICovXG4gICAgICAgICAgdGFwKCgpID0+IHsgKHJlcXVlc3QucmVzdWx0IGFzIElEQkN1cnNvcikuY29udGludWUoKTsgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGVycm9yIGV2ZW50IGFuZCBpZiBzbywgdGhyb3cgYW4gZXJyb3IgKi9cbiAgICAgICAgY29uc3QgZXJyb3IkID0gdGhpcy5saXN0ZW5FcnJvcihyZXF1ZXN0KTtcblxuICAgICAgICAvKiBDaG9vc2UgdGhlIGZpcnN0IGV2ZW50IHRvIG9jY3VyICovXG4gICAgICAgIHJldHVybiByYWNlKFtzdWNjZXNzJCwgZXJyb3IkXSk7XG5cbiAgICAgIH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIGtleSBleGlzdHMgaW4gb3VyIGBpbmRleGVkREJgIHN0b3JlXG4gICAqIEByZXR1cm5zIEFuIFJ4SlMgYE9ic2VydmFibGVgIHRlbGxpbmcgaWYgdGhlIGtleSBleGlzdHMgb3Igbm90XG4gICAqL1xuICBoYXMoa2V5OiBzdHJpbmcpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcblxuICAgIC8qIE9wZW4gYSB0cmFuc2FjdGlvbiBpbiByZWFkLW9ubHkgbW9kZSAqL1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uKCdyZWFkb25seScpLnBpcGUoXG4gICAgICBtZXJnZU1hcCgodHJhbnNhY3Rpb25EYXRhKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdG9yZSwgZXZlbnRzIH0gPSB0cmFuc2FjdGlvbkRhdGE7XG5cbiAgICAgICAgLyogQ2hlY2sgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIHN0b3JlXG4gICAgICAgICAqIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzY5XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gc3RvcmUuZ2V0S2V5KGtleSk7XG5cbiAgICAgICAgLyogTGlzdGVuIHRvIGV2ZW50cyBhbmQgcmV0dXJuIGB0cnVlYCBvciBgZmFsc2VgICovXG4gICAgICAgIHJldHVybiBldmVudHMucGlwZShtYXAoKCkgPT4gKHJlcXVlc3QucmVzdWx0ICE9PSB1bmRlZmluZWQpID8gdHJ1ZSA6IGZhbHNlKSk7XG5cbiAgICAgIH0pLFxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgZmlyc3QoKSxcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gYGluZGV4ZWREQmAgYW5kIGNyZWF0ZXMgdGhlIG9iamVjdCBzdG9yZSBvbiBmaXJzdCB0aW1lXG4gICAqL1xuICBwcm90ZWN0ZWQgY29ubmVjdCgpOiB2b2lkIHtcblxuICAgIGxldCByZXF1ZXN0OiBJREJPcGVuREJSZXF1ZXN0O1xuXG4gICAgLyogQ29ubmVjdCB0byBgaW5kZXhlZERCYFxuICAgICAqIFdpbGwgZmFpbCBpbiBTYWZhcmkgY3Jvc3Mtb3JpZ2luIGlmcmFtZXNcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vY3lyaWxsZXR1emkvYW5ndWxhci1hc3luYy1sb2NhbC1zdG9yYWdlL2lzc3Vlcy80Mn0gKi9cbiAgICB0cnkge1xuXG4gICAgICAvKiBEbyBOT1QgZXhwbGljaXQgYHdpbmRvd2AgaGVyZSwgYXMgYGluZGV4ZWREQmAgY291bGQgYmUgdXNlZCBmcm9tIGEgd2ViIHdvcmtlciB0b28gKi9cbiAgICAgIHJlcXVlc3QgPSBpbmRleGVkREIub3Blbih0aGlzLmRiTmFtZSwgdGhpcy5kYlZlcnNpb24pO1xuXG4gICAgfSBjYXRjaCB7XG5cbiAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICAvKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgY29ubmVjdGlvbiAqL1xuICAgIHRoaXMuY3JlYXRlU3RvcmUocmVxdWVzdCk7XG5cbiAgICAvKiBMaXN0ZW4gdG8gc3VjY2VzcyBhbmQgZXJyb3IgZXZlbnRzICovXG4gICAgY29uc3Qgc3VjY2VzcyQgPSBmcm9tRXZlbnQocmVxdWVzdCwgJ3N1Y2Nlc3MnKTtcbiAgICBjb25zdCBlcnJvciQgPSB0aGlzLmxpc3RlbkVycm9yKHJlcXVlc3QpO1xuXG4gICAgLyogQ2hvb3NlIHRoZSBmaXJzdCB0byBvY2N1ciAqL1xuICAgIHJhY2UoW3N1Y2Nlc3MkLCBlcnJvciRdKVxuICAgICAgLyogVGhlIG9ic2VydmFibGUgd2lsbCBjb21wbGV0ZSAqL1xuICAgICAgLnBpcGUoZmlyc3QoKSlcbiAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgLyogUmVnaXN0ZXIgdGhlIGRhdGFiYXNlIGNvbm5lY3Rpb24gaW4gdGhlIGBSZXBsYXlTdWJqZWN0YCBmb3IgZnVydGhlciBhY2Nlc3MgKi9cbiAgICAgICAgICB0aGlzLmRhdGFiYXNlLm5leHQocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogKCkgPT4ge1xuICAgICAgICAgIC8qIEZpcmVmb3ggcHJpdmF0ZSBtb2RlIGlzc3VlOiBmYWxsYmFjayBzdG9yYWdlIGlmIEluZGV4ZWREYiBjb25uZWN0aW9uIGlzIGZhaWxpbmdcbiAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc4MTk4Mn1cbiAgICAgICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXJpbGxldHV6aS9hbmd1bGFyLWFzeW5jLWxvY2FsLXN0b3JhZ2UvaXNzdWVzLzI2fSAqL1xuICAgICAgICAgIHRoaXMuZGF0YWJhc2UuZXJyb3IobmV3IElEQkJyb2tlbkVycm9yKCkpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgc3RvcmUgb24gZmlyc3QgdXNlIG9mIGBpbmRleGVkREJgXG4gICAqIEBwYXJhbSByZXF1ZXN0IGBpbmRleGVkREJgIGRhdGFiYXNlIG9wZW5pbmcgcmVxdWVzdFxuICAgKi9cbiAgcHJvdGVjdGVkIGNyZWF0ZVN0b3JlKHJlcXVlc3Q6IElEQk9wZW5EQlJlcXVlc3QpOiB2b2lkIHtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgZXZlbnQgZmlyZWQgb24gZmlyc3QgY29ubmVjdGlvbiAqL1xuICAgIGZyb21FdmVudChyZXF1ZXN0LCAndXBncmFkZW5lZWRlZCcpXG4gICAgICAvKiBUaGUgb2JzZXJ2YWJsZSB3aWxsIGNvbXBsZXRlICovXG4gICAgICAucGlwZShmaXJzdCgpKVxuICAgICAgLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcblxuICAgICAgICAgIC8qIENoZWNrIGlmIHRoZSBzdG9yZSBhbHJlYWR5IGV4aXN0cywgdG8gYXZvaWQgZXJyb3IgKi9cbiAgICAgICAgICBpZiAoIXJlcXVlc3QucmVzdWx0Lm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnModGhpcy5zdG9yZU5hbWUpKSB7XG5cbiAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgb2JqZWN0IHN0b3JlICovXG4gICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jcmVhdGVPYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGFuIGBpbmRleGVkREJgIHRyYW5zYWN0aW9uIGFuZCBnZXQgb3VyIHN0b3JlXG4gICAqIEBwYXJhbSBtb2RlIGByZWFkb25seWAgb3IgYHJlYWR3cml0ZWBcbiAgICogQHJldHVybnMgQW4gYGluZGV4ZWREQmAgdHJhbnNhY3Rpb24gc3RvcmUgYW5kIGV2ZW50cywgd3JhcHBlZCBpbiBhbiBSeEpTIGBPYnNlcnZhYmxlYFxuICAgKi9cbiAgcHJvdGVjdGVkIHRyYW5zYWN0aW9uKG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSk6IE9ic2VydmFibGU8e1xuICAgIHN0b3JlOiBJREJPYmplY3RTdG9yZTtcbiAgICBldmVudHM6IE9ic2VydmFibGU8RXZlbnQ+O1xuICB9PiB7XG5cbiAgICAvKiBGcm9tIHRoZSBgaW5kZXhlZERCYCBjb25uZWN0aW9uLCBvcGVuIGEgdHJhbnNhY3Rpb24gYW5kIGdldCB0aGUgc3RvcmUgKi9cbiAgICByZXR1cm4gdGhpcy5kYXRhYmFzZVxuICAgICAgLnBpcGUobWVyZ2VNYXAoKGRhdGFiYXNlKSA9PiB7XG5cbiAgICAgICAgbGV0IHRyYW5zYWN0aW9uOiBJREJUcmFuc2FjdGlvbjtcblxuICAgICAgICB0cnkge1xuXG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSBkYXRhYmFzZS50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdLCBtb2RlKTtcblxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuXG4gICAgICAgICAgICAvKiBUaGUgc3RvcmUgY291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQgZnJvbSBvdXRzaWRlICovXG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciBhcyBET01FeGNlcHRpb24pO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvKiBHZXQgdGhlIHN0b3JlIGZyb20gdGhlIHRyYW5zYWN0aW9uICovXG4gICAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuXG4gICAgICAgIC8qIExpc3RlbiB0cmFuc2FjdGlvbiBgY29tcGxldGVgIGFuZCBgZXJyb3JgIGV2ZW50cyAqL1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLmxpc3RlblRyYW5zYWN0aW9uRXZlbnRzKHRyYW5zYWN0aW9uKTtcblxuICAgICAgICByZXR1cm4gb2YoeyBzdG9yZSwgZXZlbnRzIH0pO1xuXG4gICAgICB9KSk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gZXJyb3JzIG9uIGEgdHJhbnNhY3Rpb24gb3IgcmVxdWVzdCwgYW5kIHRocm93IGlmIHRyaWdlcnJlZFxuICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25PclJlcXVlc3QgYGluZGV4ZWREYmAgdHJhbnNhY3Rpb24gb3IgcmVxdWVzdCB0byBsaXN0ZW5cbiAgICogQHJldHVybnMgQW4gYE9ic2VydmFibGVgIGxpc3RlbmluZyB0byBlcnJvcnNcbiAgICovXG4gIHByb3RlY3RlZCBsaXN0ZW5FcnJvcih0cmFuc2FjdGlvbk9yUmVxdWVzdDogSURCVHJhbnNhY3Rpb24gfCBJREJSZXF1ZXN0KTogT2JzZXJ2YWJsZTxuZXZlcj4ge1xuXG4gICAgcmV0dXJuIGZyb21FdmVudCh0cmFuc2FjdGlvbk9yUmVxdWVzdCwgJ2Vycm9yJykucGlwZShcbiAgICAgIC8qIFRocm93IG9uIGVycm9yIHRvIGJlIGFibGUgdG8gY2F0Y2ggZXJyb3JzIGluIFJ4SlMgd2F5LlxuICAgICAgICogSGVyZSBgZXZlbnQudGFyZ2V0YCBtdXN0IGJlIHVzZWQsIGFzIGB0cmFuc2FjdGlvbk9yUmVxdWVzdC5lcnJvcmAgd2lsbCBiZSBgbnVsbGBcbiAgICAgICAqIGlmIHdlIGFyZSBvbiB0aGUgcmVxdWVzdCBhbmQgdGhlIGVycm9yIGlzIG9ubHkgdHJpZ2dlcmVkIGxhdGVyIGJ5IHRoZSB0cmFuc2FjdGlvbiAqL1xuICAgICAgbWVyZ2VNYXAoKGV2ZW50KSA9PiB0aHJvd0Vycm9yKChldmVudC50YXJnZXQgYXMgSURCVHJhbnNhY3Rpb24gfCBJREJSZXF1ZXN0KS5lcnJvcikpLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdHJhbnNhY3Rpb24gYGNvbXBsZXRlYCBhbmQgYGVycm9yYCBldmVudHNcbiAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIGxpc3RlblxuICAgKiBAcmV0dXJucyBBbiBgT2JzZXJ2YWJsZWAgbGlzdGVuaW5nIHRvIHRyYW5zYWN0aW9uIGBjb21wbGV0ZWAgYW5kIGBlcnJvcmAgZXZlbnRzXG4gICAqL1xuICBwcm90ZWN0ZWQgbGlzdGVuVHJhbnNhY3Rpb25FdmVudHModHJhbnNhY3Rpb246IElEQlRyYW5zYWN0aW9uKTogT2JzZXJ2YWJsZTxFdmVudD4ge1xuXG4gICAgLyogTGlzdGVuIHRvIHRoZSBgY29tcGxldGVgIGV2ZW50ICovXG4gICAgY29uc3QgY29tcGxldGUkID0gZnJvbUV2ZW50KHRyYW5zYWN0aW9uLCAnY29tcGxldGUnKTtcblxuICAgIC8qIExpc3RlbiB0byB0aGUgYGVycm9yYCBldmVudCAqL1xuICAgIGNvbnN0IGVycm9yJCA9IHRoaXMubGlzdGVuRXJyb3IodHJhbnNhY3Rpb24pO1xuXG4gICAgLyogQ2hvb3NlIHRoZSBmaXJzdCBldmVudCB0byBvY2N1ciAqL1xuICAgIHJldHVybiByYWNlKFtjb21wbGV0ZSQsIGVycm9yJF0pO1xuXG4gIH1cblxufVxuIl19